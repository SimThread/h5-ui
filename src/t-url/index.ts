/**
 * 拷贝自[vux](https://vux.li/)
 */
// QueryString
// ---------------
// This module provides utilities for dealing with query strings.
//
// Thanks to:
//  - http://nodejs.org/docs/v0.4.7/api/querystring.html
//  - http://developer.yahoo.com/yui/3/api/QueryString.html
//  - https://github.com/lifesinger/dew/tree/master/lib/querystring


// The escape/unescape function used by stringify/parse, provided so that it
// could be overridden if necessary. This is important in cases where
// non-standard delimiters are used, if the delimiters would not normally be
// handled properly by the built-in (en|de)codeURIComponent functions.

/**
 * Checks to see if an object is a plain object (created using "{}" or
 * "new Object()" or "new FunctionClass()").
 */

// Helpers

const { toString } = Object.prototype;
const { hasOwnProperty } = Object.prototype;
const isArray = Array.isArray || function (val) {
    return toString.call(val) === '[object Array]';
};

const trim = String.prototype.trim ?
    function (str: any) {
        return (str == null) ?
            '' :
            String.prototype.trim.call(str);
    } :
    function (str: any) {
        return (str == null) ?
            '' :
            str.toString().replace(/^\s+/, '').replace(/\s+$/, '');
    };

function isPlainObject(o: any) {
    /**
   * NOTES:
   * isPlainObject(node = document.getElementById("xx")) -> false
   * toString.call(node):
   *   ie678 === '[object Object]', other === '[object HTMLElement]'
   * 'isPrototypeOf' in node:
   *   ie678 === false, other === true
   */
    // eslint-disable-next-line no-use-before-define
    return o && toString.call(o) === '[object Object]' && 'isPrototypeOf' in o;
}

/**
 * If the type of o is null, undefined, number, string, boolean,
 * return true.
 */
function isPrimitive(o: any) {
    return o !== Object(o);
}

export const escape = encodeURIComponent;

export const unescape = function (s: any) {
    // The + character is interpreted as a space on the server side as well as
    // generated by forms with spaces in their fields.
    return decodeURIComponent(s.replace(/\+/g, ' '));
};

/**
 * Serialize an object to a query string. Optionally override the default
 * separator and assignment characters.
 *
 * stringify({foo: 'bar'})
 *   // returns 'foo=bar'
 *
 * stringify({foo: 'bar', baz: 'bob'}, ';', ':')
 *   // returns 'foo:bar;baz:bob'
 */
export const stringify = function (obj: any, sep: any, eq: any, arrayKey: any) {
    if (!isPlainObject(obj)) return '';

    sep = sep || '&';
    eq = eq || '=';
    arrayKey = arrayKey || false;

    const buf:any[] = [];
    let val;
    const { escape } = window;

    Object.keys(obj).forEach((key: any) => {
        if (!hasOwnProperty.call(obj, key)) return;

        val = obj[key];
        key = escape(key);

        // val is primitive value
        if (isPrimitive(val)) {
            buf.push(key, eq, escape(val + ''), sep);
        } else if (isArray(val) && val.length) { // val is not empty array
            for (let i = 0; i < val.length; i++) {
                if (isPrimitive(val[i])) {
                    buf.push(
                        key,
                        (arrayKey ? escape('[]') : '') + eq,
                        escape(val[i] + ''),
                        sep);
                }
            }
        } else { // ignore other cases, including empty array, Function, RegExp, Date etc.
            buf.push(key, eq, sep);
        }
    });

    buf.pop();
    return buf.join('');
};

/**
 * Deserialize a query string to an object. Optionally override the default
 * separator and assignment characters.
 *
 * parse('a=b&c=d')
 *   // returns {a: 'b', c: 'c'}
 */
export const parse = function (str: any, sep: any, eq: any) {
    if (typeof str === 'undefined' && typeof document !== 'undefined') {
        str = document.location.search;
    }
    const ret: {
        [key: string]: any
    } = {};

    if (typeof str !== 'string' || trim(str).length === 0) {
        return ret;
    }

    // remove ^?
    str = str.replace(/^\?/, '');

    const pairs = str.split(sep || '&');
    eq = eq || '=';
    const { unescape } = window;

    for (let i = 0; i < pairs.length; i++) {
        const pair = pairs[i].split(eq);
        let key = unescape(trim(pair[0]));
        const val = unescape(trim(pair.slice(1).join(eq)));

        const m = key.match(/^(\w+)\[\]$/);
        if (m && m[1]) {
            key = m[1];
        }

        if (hasOwnProperty.call(ret, key)) {
            if (!isArray(ret[key])) {
                ret[key] = [ret[key]];
            }
            ret[key].push(val);
        } else {
            ret[key] = m ? [val] : val;
        }
    }

    return ret;
};

export default {
    escape,
    unescape,
    stringify,
    parse
};
